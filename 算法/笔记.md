# 排序

## 认识时间复杂度 

### 常数时间的操作 

**一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。** 

时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作big O)来表示。

具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作， 进而总结出常数操作数量的表达式。 

在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那 么时间复杂度为O(f(N))。 

评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行 时间，也就是“常数项时间”。

## 选择排序

**时间复杂度O(N^2)，额外空间复杂度O(1)**

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

### 1. 算法步骤

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。

再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

重复第二步，直到所有元素均排序完毕。

### 2. 动图演示

![img](images/selectionSort.gif)
### 3. 代码
```java
public static void selectionSort(int[] arr) {
    // 如果需要排序的数组为null，或者元素只有一个，返回
    if (arr == null || arr.length < 2) {
        return;
    }
    // 从第一个元素开始遍历
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i;
        // 遍历后续元素
        for (int j = i + 1; j < arr.length; j++) {
            // 记录 最小元素的下标
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        // 将已排序的最后一个和未排序元素的最小值交换
        swap(arr, i, minIndex);
    }
}

public static void swap(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
```

## 冒泡排序

**时间复杂度O(N^2)，额外空间复杂度O(1)**

### 1. 算法步骤

比较相邻的元素。如果第一个比第二个大，就交换他们两个。

对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

针对所有的元素重复以上的步骤，除了最后一个。

持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### 2. 动图演示

![img](images/bubbleSort.gif)

### 3. 什么时候最快

当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。

### 4. 什么时候最慢

当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。
### 5. 代码
```java
public static void bubbleSort(int[] arr) {
    // 如果需要排序的数组为null，或者元素只有一个，返回
    if (arr == null || arr.length < 2) {
        return;
    }
    // 从整个数组开始，先计算 e 位置处的元素
    for (int e = arr.length - 1; e > 0; e--) {
        // 从第一个元素开始，依次对比两个相邻元素的大小
        // 一次循环结束，数组最大位置即e处，就是最大元素，然后计算 e-1 位置处的元素
        for (int i = 0; i < e; i++) {
            if (arr[i] > arr[i + 1]) {
                swap(arr, i, i + 1);
            }
        }
    }
}

public static void swap(int[] arr, int i, int j) {
    arr[i] = arr[i] ^ arr[j];
    arr[j] = arr[i] ^ arr[j];
    arr[i] = arr[i] ^ arr[j];
}
```

## 插入排序

**时间复杂度O(N^2)，额外空间复杂度O(1)** 

算法流程按照最差情况来估计时间复杂度

### 1. 算法步骤

将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

### 2. 动图演示

![img](images/insertionSort.gif)

### 3. 代码

```java
public static void insertionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }

    // 从第一个元素开始（新拿的牌），等效于手中已经有一张牌（第0个元素）
    for (int i = 1; i < arr.length; i++) {
        // 从右开始依次对比手中已经有的牌大小，如果新牌小于要比较的牌，则交换，否则结束比较
        // 从第i - 1个元素开始比较，如果 j 没有达到第一个元素 && j(手中有序最后一张牌) 大于 j+1=i新牌
        for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
            // 交换
            swap(arr, j, j + 1);
        }
    }
}

public static void swap(int[] arr, int i, int j) {
    arr[i] = arr[i] ^ arr[j];
    arr[j] = arr[i] ^ arr[j];
    arr[i] = arr[i] ^ arr[j];
}
```

## 归并排序 

**时间复杂度O(N*logN)，额外空间复杂度O(N)**

归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：

- 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；
- 自下而上的迭代；

### 1. 算法步骤

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
4. 重复步骤 3 直到某一指针达到序列尾；
5. 将另一序列剩下的所有元素直接复制到合并序列尾。

### 2. 动图演示

![img](images/mergeSort.gif)

### 3. 代码

```java
public static void mergeSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    mergeSort(arr, 0, arr.length - 1);
}

/**
     *
     * @param arr 要排序的数组
     * @param l 左侧索引
     * @param r 右侧索引
     */
public static void mergeSort(int[] arr, int l, int r) {
    if (l == r) {
        return;
    }
    // 获取最中间位置
    int mid = l + ((r - l) >> 1);
    // 左边排序
    mergeSort(arr, l, mid);
    // 右边排序
    mergeSort(arr, mid + 1, r);
    // 合并
    merge(arr, l, mid, r);
}

/**
     *
     * @param arr 要排序的数组
     * @param l 左侧索引
     * @param m 中间位置索引
     * @param r 右侧索引
     */
public static void merge(int[] arr, int l, int m, int r) {
    // 定义一个辅助数组，为了合并数组，长度为要合并数组的长度，比如原数组长度为10，第一次进入时，左侧 l=0，m=5，r=9
    int[] help = new int[r - l + 1];
    int i = 0;
    // 左侧数组指针
    int p1 = l;
    // 右侧数组指针
    int p2 = m + 1;
    // 循环 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
    while (p1 <= m && p2 <= r) {
        help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
    }

    // 下面两个循环只会进入一个，左右两个数组，有一个会先处理完

    // 复制左侧数组
    while (p1 <= m) {
        help[i++] = arr[p1++];
    }
    // 复制右侧数组
    while (p2 <= r) {
        help[i++] = arr[p2++];
    }
    // 此时辅助组数已经排好序，复制到原数组中去
    for (i = 0; i < help.length; i++) {
        arr[l + i] = help[i];
    }
}
```

## 堆排序 

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：

1. 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
2. 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；

### heapInsert

**将一个数组变成大根堆的过程**

它可以假定我们事先不知道有多少个元素，通过不断往堆里面插入元素进行调整来构建堆。

它的大致步骤如下：

1. 首先增加堆的长度，在最末尾的地方加入最新插入的元素。
2. 比较当前元素和它的父结点值，如果比父结点值大，则交换两个元素，否则返回。
3. 重复步骤2.

**这种插入建堆的时间复杂度是O(NlogN)**

### heapify

**将一颗二叉树变成小根堆的过程**

从最后一个非叶子节点一直到根结点进行堆化的调整。如果当前节点小于某个自己的孩子节点（大根堆中），那么当前节点和这个孩子交换。

Heapify是一种类似下沉的操作，HeapInsert是一种类似上浮的操作。

### 1. 算法步骤

1. 先让整个数组都变成大根堆结构，建立堆的过程: 

   1)从上到下的方法，时间复杂度为O(N*logN) 

   2)从下到上的方法，时间复杂度为O(N) 

2. 把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N*logN) 

3. 堆的大小减小成0之后，排序完成

### 2. 动图演示

![img](images/heapSort-163688030837912.gif)

## 快速排序

### 1. 算法步骤

1. 从数列中挑出一个元素，称为 "基准"（pivot）;
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

### 2. 动图演示

![img](images/quickSort.gif)

### 3. 代码

```java
public static void quickSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		quickSort(arr, 0, arr.length - 1);
	}

    /**
     *
     * @param arr 原数组
     * @param l 左侧索引
     * @param r 右侧索引
     */
	public static void quickSort(int[] arr, int l, int r) {
        //
		if (l < r) {
            // 随机选择一个数作为排序‘基数’，将其放入到数组最右侧，即r
			swap(arr, l + (int) (Math.random() * (r - l + 1)), r);
            // 分区
			int[] p = partition(arr, l, r);
			quickSort(arr, l, p[0] - 1);
			quickSort(arr, p[1] + 1, r);
		}
	}

    /**
     *  处理 arr[l...r]
     *  默认以arr[r]做划分，arr[r] -> p，分为三块区域     <p | ==p | > p
     *  返回等于区域(左边界，有边界)，所以返回一个长度为2的数组res，res[0],res[1]
     * @param arr 原数组
     * @param l 要分区的左侧索引
     * @param r 要分区的右侧索引
     * @return
     */
	public static int[] partition(int[] arr, int l, int r) {
        // 比基数小的最大索引，目前是-1
		int less = l - 1; // <区的右边界
        // 比基数大的最大索引，目前就是“基数”位置处索引
		int more = r; // >区的左边界
        // 循环，表示两个索引还没有重叠
		while (l < more) { // l表示当前数的位置 arr[r] -> 基数
			if (arr[l] < arr[r]) { // 当前数 < 基数
				swap(arr, ++less, l++); // 先和<区最右侧数交换，然后<区域向右扩一个位置
			} else if (arr[l] > arr[r]) { // // 当前数 > 基数
				swap(arr, --more, l); // 先和>区最左侧数交换，然后>区域向左扩一个位置
			} else { // 当前数等于基数，直接跳下一个
				l++;
			}
		}
        // 最后将>区左边界的数和基数做交换
		swap(arr, more, r);
        // 返回 arr[[<=p], [>p]] 的两个数组
		return new int[] { less + 1, more };
	}
```

## 总结

![](./images/sort.png)

![](./images/sort2.png)

## 排序算法的稳定性及其汇总 

同样值的个体之间，如果不因为排序而改变相对次序，就是这个排序是有稳定性的；否则就没有。

- 不具备稳定性的排序： 

选择排序、快速排序、堆排序 

- 具备稳定性的排序： 

冒泡排序、插入排序、归并排序、一切桶排序思想下的排序 

**目前没有找到时间复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序。**

## 常见的坑 

1. 归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握，有兴 趣可以搜“归并排序 内部缓存法” 

2. “原地归并排序”的帖子都是垃圾，会让归并排序的时间复杂度变成O(N^2) 

3. 快速排序可以做到稳定性问题，但是非常难，不需要掌握， 可以搜“01 stable sort” 

4. 所有的改进都不重要，因为目前没有找到时间复杂度O(N*logN)，额外空间复 杂度O(1)，又稳定的排序。 

5. 有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，碰到这个问题，可以怼面试官

   类似于荷兰国旗问题，使用快速排序，partition时会交换数组中的位置

## 工程上对排序的改进 

1）充分利用O(N*logN)和O(N^2)排序各自的优势 

2）稳定性的考虑

# 链表

## 面试时链表解题的方法论 

1）对于笔试，不用太在乎空间复杂度，一切为了时间复杂度 

2）对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法 

重要技巧： 

1）额外数据结构记录（哈希表等） 

2）快慢指针

## 反转单向和双向链表 

【题目】 分别实现反转单向链表和反转双向链表的函数 

【要求】 如果链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为 O(1)

## 打印两个有序链表的公共部分 

【题目】 给定两个有序链表的头指针head1和head2，打印两个链表的公共部分。 

【要求】 如果两个链表的长度之和为N，时间复杂度要求为O(N)，额外空间复 杂度要求为O(1)

## 判断一个链表是否为回文结构 

【题目】给定一个单链表的头节点head，请判断该链表是否为回文结构。 

【例子】1->2->1，返回true； 1->2->2->1，返回true；15->6->15，返回true； 1->2->3，返回false。 

【例子】如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)。

## 将单向链表按某值划分成左边小、中间相等、右边大的形式 

【题目】给定一个单链表的头节点head，节点的值类型是整型，再给定一个整 数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。 

【进阶】在实现原问题功能的基础上增加如下的要求 

【要求】调整后所有小于pivot的节点之间的相对顺序和调整前一样 

【要求】调整后所有等于pivot的节点之间的相对顺序和调整前一样 

【要求】调整后所有大于pivot的节点之间的相对顺序和调整前一样 

【要求】时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。

## 复制含有随机指针节点的链表 

【题目】一种特殊的单链表节点类描述如下 

```java
class Node { 
    int value; 
    Node next; 
    Node rand; 
    Node(int val) { 
        value = val; 
    } 
}
```

rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节 点，也可能指向null。给定一个由Node节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。 

【要求】时间复杂度O(N)，额外空间复杂度O(1)

## 两个单链表相交的一系列问题 

【题目】给定两个可能有环也可能无环的单链表，头节点head1和head2。请实 现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null 

【要求】如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。
